import{_ as t,c as a,a0 as i,o as s}from"./chunks/framework.DjKIygR6.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"DOM-ORM","text":"Document Object Model Object Relational Mapping","tagline":"Using a standardized XML tree structure to store data objects in a Doctrine-like fashion into an XML flatfile.","actions":[{"theme":"brand","text":"Quickstart","link":"/quickstart"},{"theme":"alt","text":"Usage Examples","link":"/usage-examples"}]},"features":[{"title":"One-to-One Relationships","details":"Lorem ipsum dolor sit amet, consectetur adipiscing elit"},{"title":"One-to-many Relationships","details":"Lorem ipsum dolor sit amet, consectetur adipiscing elit"},{"title":"Many-to-one Relationships","details":"Lorem ipsum dolor sit amet, consectetur adipiscing elit"},{"title":"Many-to-Many Relationships","details":"Lorem ipsum dolor sit amet, consectetur adipiscing elit"}]},"headers":[],"relativePath":"index.md","filePath":"index.md"}'),n={name:"index.md"};function o(r,e,l,h,d,c){return s(),a("div",null,e[0]||(e[0]=[i('<h2 id="why" tabindex="-1">Why? <a class="header-anchor" href="#why" aria-label="Permalink to &quot;Why?&quot;">​</a></h2><p>The DOM-ORM project was created to provide a simple, easy-to-use, and lightweight way to store data objects without the need to setup and configure a database, users. That said, the project is not meant to replace databases, but rather to provide an alternative with a focus on tree structures like navigations, categories, tag trees, translations, etc. things that dont necessarily need to be stored in a database.</p><h2 id="querying-data" tabindex="-1">Querying Data <a class="header-anchor" href="#querying-data" aria-label="Permalink to &quot;Querying Data&quot;">​</a></h2><p>XPath is the query language used to query the XML tree structure. So unlike writing SQL queries as you would when using a database, you write XPath queries to query the XML tree structure. But just like Doctrine ORM, that returns an entity object, DOM-ORM does the same and instantiates the object from the node(s) found in the XML file.</p><h2 id="caveats" tabindex="-1">Caveats <a class="header-anchor" href="#caveats" aria-label="Permalink to &quot;Caveats&quot;">​</a></h2><p>In order to have XPath make a query against your data file, PHP needs to read the entire file into memory. This is not a problem for small to medium-sized files. This is something to keep in mind when working with large files.</p><h2 id="relationships" tabindex="-1">Relationships <a class="header-anchor" href="#relationships" aria-label="Permalink to &quot;Relationships&quot;">​</a></h2><p>A standard XML tree structure already allows to represent relationships between nodes by where they are in the tree. For example, a category tree where a category can have subcategories. This is a one-to-many relationship. The parent category has many subcategories. The subcategories have one parent category. This is represented by the parent node having child nodes. Or similarly, think of an author, that wrote n articles. The author node has n article nodes as children. The article nodes have one author node as parent. This is a many-to-one relationship.</p><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">composer</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> require</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vardumper/dom-orm</span></span></code></pre></div>',10)]))}const m=t(n,[["render",o]]);export{p as __pageData,m as default};
